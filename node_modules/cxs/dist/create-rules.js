'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.kebab = exports.parseValue = exports.createRuleset = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _addPxToStyle = require('add-px-to-style');

var _addPxToStyle2 = _interopRequireDefault(_addPxToStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var createRules = function createRules(name, style, parent) {
  // Extract nested rules
  var rules = createNestedRules(name, style, parent);

  if (!name) return rules;

  // Create styles array
  var styles = Object.keys(style).filter(function (key) {
    return style[key] !== null;
  }).filter(function (key) {
    return isArr(style[key]) || !isObj(style[key]);
  }).map(function (key) {
    return {
      key: key,
      prop: kebab(key),
      value: parseValue(key, style[key])
    };
  }).reduce(function (a, b) {
    return isArr(b.value) ? [].concat(_toConsumableArray(a), _toConsumableArray(b.value.map(function (v) {
      return _extends({}, b, { value: v });
    }))) : [].concat(_toConsumableArray(a), [b]);
  }, []);

  // Add base rule
  var selector = /^cxs/.test(name) ? '.' + name : name;

  if (/^@keyframes/.test(parent)) {
    return [{
      id: name + parent,
      selector: selector,
      css: createRuleset(selector, styles)
    }];
  }

  rules.unshift({
    id: name + (parent || ''),
    selector: selector,
    css: createRuleset(selector, styles, parent)
  });

  return rules;
};

var createNestedRules = function createNestedRules(name, style, parent) {
  return Object.keys(style).filter(function (key) {
    return !!style[key];
  }).filter(function (key) {
    return !isArr(style[key]) && isObj(style[key]);
  }).map(function (key) {
    if (/^:/.test(key)) {
      return createRules(name + key, style[key], parent);
    } else if (/^@keyframes/.test(key)) {
      var subrules = createRules(null, style[key], key);
      return [{
        id: key,
        selector: key,
        css: key + ' { ' + subrules.map(function (r) {
          return r.css;
        }).join('') + ' }'
      }];
    } else if (/^@/.test(key)) {
      return createRules(name, style[key], key);
    } else {
      var selector = name ? name + ' ' + key : key;
      return createRules(selector, style[key], parent);
    }
  }).reduce(function (a, b) {
    return a.concat(b);
  }, []);
};

var createRuleset = exports.createRuleset = function createRuleset(selector, styles, parent) {
  var declarations = styles.map(function (s) {
    return s.prop + ':' + s.value;
  });
  var ruleset = selector + '{' + declarations.join(';') + '}';
  return parent ? parent + ' { ' + ruleset + ' }' : ruleset;
};

var isObj = function isObj(v) {
  return (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object';
};
var isArr = function isArr(v) {
  return Array.isArray(v);
};

var parseValue = exports.parseValue = function parseValue(prop, val) {
  return typeof val === 'number' ? (0, _addPxToStyle2.default)(prop, val) : val;
};
var kebab = exports.kebab = function kebab(str) {
  return str.replace(/([A-Z]|^ms)/g, function (g) {
    return '-' + g.toLowerCase();
  });
};

exports.default = createRules;